###########################################################################
#
#  Copyright 2020 Google LLC
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#
###########################################################################

import json
import re

from collections import defaultdict


RE_TEXT_FIELD = re.compile(r'\{\w+:(\w+)(, .*?)?}')
RE_MARKDOWN_LINK = re.compile(r'\[(.*?)\]\((.*?)\)')
RE_MARKDOWN_BOLD = re.compile(r'\*\*(.*?)\*\*')

def get_recipe(filepath=None, includepath=None, stringcontent=None):
  """Loads json for recipe, replaces newlines, and expands includes.

    Args:
     - filepath: (string) The local file path to the recipe json file to load.

    Returns:
      Dictionary of recipe file.

  """

  if filepath:
    with open(filepath) as recipe_file:
      stringcontent = recipe_file.read()

  try:
    # allow the json to contain newlines for formatting queries and such
    return recipe_includes(
      json.loads(stringcontent.replace('\n', ' ')),
      includepath
    )
  except ValueError as e:
    pos = 0
    for count, line in enumerate(stringcontent.splitlines(), 1):
      # do not add newlines, e.pos was run on a version where newlines were removed
      pos += len(line)
      if pos >= e.pos:
        e.lineno = count
        e.pos = pos
        e.args = (
          'JSON ERROR: %s LINE: %s CHARACTER: %s ERROR: %s LINE: %s' %
          (filepath, count, pos - e.pos, str(e.msg), line.strip()),
        )
        raise


def recipe_includes(recipe, path=None):
  """Expands include block and merges fields.

  This ONLY transforms a recipe by merging fields not resolving them.
  All fields remain as fields but parameters in the include are written
  over the fields in the included recipe.

  For example:

    { "include":{
      "script":"scripts/dv360_segmentology.json",
      "parameters":{
        "auth_read":"user",
        "auth_write":"service",
        "recipe_name":{"field":{ "name":"test_run_id", "kind":"string", "description":"The name to use for the test.", "prefix":"StarThinker Test Segmentology DV ", "default": "Manual"}},
        "partners":{"field":{ "name":"partners", "kind":"integer_list", "default":[], "description":"DV360 partner id." }},
      }

  Generated by:

    python starthinker/tool/test.py -i scripts/dv360_segmentology.json

    Args:
     - recipe: (dict) A json recipe that may include { "include":... } task.
     - path: (string) The file path where included recipes are to be read from.

    Returns:
      Dictionary with tasks from all includes and fields merged.

  """

  expanded_tasks = []
  for task in recipe['tasks']:
    function, parameters = next(iter(task.items()))

    if function == 'include':
      if path:
        tasks = get_recipe(path + '/' + parameters['script'])['tasks']
        json_merge_fields(tasks, parameters['parameters'])
        expanded_tasks.extend(tasks)
      else:
        raise FileNotFoundError('Script contains INCLUDE but no include path specified: %s' % path + '/' + parameters['script'])

    else:
      expanded_tasks.append({function: parameters})

  recipe['tasks'] = expanded_tasks
  return recipe


def fields_to_string(fields, values={}):
  """Converts fields to a dictionary of parameters as a string.

  Used to generate input blocks in generated code.

  For example:
    {
      'auth':'user', # authentication to use for call.
      'name':'value', # parameter to pass to function.
    }

  Args:
   - fields: (list) Contains {"field":{...}} objects to be rendered as imputs.
   - values: (dict) Default values to use for each field.

  Returns:
    String representing python code to be written to a generated file.

  """

  items = [
      repr(field['name']) + ':' +
      repr(values.get(field['name'], field.get('default', ''))) + ',' +
      ('  # %s' % field['description'] if 'description' in field else '')
      for field in fields
  ]
  return ('{\n  %s\n}' % ('\n  '.join(items))) if items else '{}'


def dict_to_string(value, char_indent='  ', char_line='\n', skip=[], indent=0):
  nlch = char_line + char_indent * (indent + 1)
  if type(value) is dict:
    is_skip = any(k in value for k in skip)
    items = [('' if is_skip else nlch) + repr(key) + ':' +
             dict_to_string(value[key], '' if is_skip else char_indent,
                            '' if is_skip else char_line, skip, indent + 1)
             for key in value]
    return '{%s}' % (','.join(items) +
                     ('' if is_skip else char_line + char_indent * indent))
  elif type(value) is list:
    items = [
        nlch + dict_to_string(item, char_indent, char_line, skip, indent + 1)
        for item in value
    ]
    return '[%s]' % (','.join(items) + char_line + char_indent * indent)
  elif type(value) is tuple:
    items = [
        nlch + dict_to_string(item, char_indent, char_line, skip, indent + 1)
        for item in value
    ]
    return '(%s)' % (','.join(items) + char_line + char_indent * indent)
  else:
    return repr(value)


def dict_to_python(value, char_indent='  ', char_line='\n', indent=0):
  nlch = char_line + char_indent * (indent + 1)

  if type(value) is dict:
    if 'field' in value: return value['field']['name']
    else:
      items = [
        nlch +
        repr(key) + ':' +
        dict_to_python(value[key], char_indent, char_line, indent + 1)
      for key in value]

      return '{%s}' % (','.join(items) + (char_line + char_indent * indent))

  elif type(value) is list:
    items = [
      nlch +
      dict_to_python(item, char_indent, char_line, indent + 1)
    for item in value]

    return '[%s]' % (','.join(items) + char_line + char_indent * indent)

  elif type(value) is tuple:
    items = [
      nlch +
      dict_to_python(item, char_indent, char_line, indent + 1)
    for item in value]

    return '(%s)' % (','.join(items) + char_line + char_indent * indent)

  elif type(value) is str:
    if '\n' in value:
      return "'''%s'''" % value
    else:
      return "'%s'" % value
  else:
    return repr(value)


def json_to_string(value, char_indent='  ', char_line='\n', skip=[], indent=0):
  nlch = char_line + char_indent * (indent + 1)
  if type(value) is dict:
    is_skip = any(k in value for k in skip)
    items = [('' if is_skip else nlch) + json.dumps(key) + ':' +
             json_to_string(value[key], '' if is_skip else char_indent,
                            '' if is_skip else char_line, skip, indent + 1)
             for key in value]
    return '{%s}' % (', '.join(items) +
                     ('' if is_skip else char_line + char_indent * indent))
  elif type(value) in (list, tuple):
    items = [
        nlch + json_to_string(item, char_indent, char_line, skip, indent + 1)
        for item in value
    ]
    return '[%s]' % (','.join(items) + char_line + char_indent * indent)
  else:
    return json.dumps(value)


def json_set_auths(recipe, auth):
  """Recusrsively finds auth in script JSON and sets them.

    Args:
      recipe: (dict) A dictionary representation fo the JSON script.
      auth: (string) Either 'service' or 'user'.

    Returns:
      (recipe) same structure but with all auth fields replaced.

  """

  if isinstance(recipe, dict):
    if 'auth' in recipe:
      recipe['auth'] = auth
    for key, value in recipe.items():
      json_set_auths(value, auth)
  elif isinstance(recipe, list) or isinstance(recipe, tuple):
    for index, value in enumerate(recipe):
      json_set_auths(value, auth)

  return recipe


def json_get_fields(recipe, path=[]):
  """Recusrsively finds fields in script JSON and returns them as a list.

     Field has format: { "field":{ "name":"???", "kind":"???", "default":???,
     "description":"???" }}

    Args:
      recipe: (dict) A dictionary representation fo the JSON script.
      path: (list) Stack that keeps track of recursion depth. Not used
        externally.

    Returns:
      fields: (list or dictionary) A list or dictionary representing each field recipe found
      in the JSON.

  """

  fields = {}
  path = path[:]
  if isinstance(recipe, dict):
    if 'field' in recipe:
      fields[recipe['field']['name']] = recipe['field']
    else:
      for key, value in recipe.items():
        fields.update(json_get_fields(value, path + [key]))
  elif isinstance(recipe, list) or isinstance(recipe, tuple):
    for index, value in enumerate(recipe):
      fields.update(json_get_fields(value, path + [index]))

  if path == []:
    return sorted(
      fields.values(),
      key=lambda f: f.get('order', 0)
    )  # sort only on last step of recursion
  else:
    return fields  # do not sort if deep in recursion


def get_field_value(field, value):
  if value is not None and 'prefix' in field['field']:
    value = '%s%s' % (field['field']['prefix'], value)
  if value is not None and 'suffix' in field['field']:
    value = '%s%s' % (value, field['field']['suffix'])
  return value


def json_set_fields(recipe, variables):
  """Recusrsively replaces fields in script JSON with values provided.

     Field has format: { "field":{ "name":"???", "kind":"???", "default":???,
     "description":"???" }}

     If field value is empty and field default is null, the value is removed
     from JSON as a parameter,
     allowing the python task to pick a default value. Allows optional
     parameters to exist.

    Args:
      recipe: (dict) A dictionary representation of the JSON script.
      variables: (dict) A lookup table of all values to be replaced, key is name
        of field.

    Returns:
      Nothig. Struct is modified in place.

  """

  if isinstance(recipe, dict):
    for key, value in list(recipe.items()):
      if isinstance(value, dict) and 'field' in value:
        variable_value = variables.get(value['field']['name'], value['field'].get('default'))
        field_value = get_field_value(value, variable_value)
        if field_value is None and value.get('default') is None:
          del recipe[key]
        else:
          recipe[key] = field_value
      else:
        json_set_fields(value, variables)
  elif isinstance(recipe, list) or isinstance(recipe, tuple):
    for index, value in enumerate(recipe):
      if isinstance(value, dict) and 'field' in value:
        variable_value = variables.get(value['field']['name'], value['field'].get('default'))
        recipe[index] = get_field_value(value, variable_value)
      else:
        json_set_fields(value, variables)

  return recipe


def json_merge_field(field_to, field_from):
  """When a field value is replaced by another field via include.

  Replaces the included field with the new field value.
  The value can be another field or an actual value.

  Args:
    field_to - a { 'field':{...}} dictionary.
    field_from - a { 'field':{...}} dictionary.

  Returns:
    A field or value containg the new data.

  """

  # if field - field
  if isinstance(field_from, dict) and 'field' in field_from:
    field_to['field']['name'] = field_from['field']['name']
    field_to['field']['description'] = field_from['field'].get('description', '')

    if 'default' in field_from['field']:
      field_to['field']['default'] = field_from['field']['default']

    if 'prefix' in field_from['field'] or 'prefix' in field_to['field']:
      field_to['field']['prefix'] = field_to['field'].get('prefix', '') + field_from['field'].get('prefix' , '')

    if 'suffix' in field_from['field'] or 'suffix' in field_to['field']:
      field_to['field']['suffix'] = field_from['field'].get('suffix', '') + field_to['field'].get('suffix' , '')

  # if value - field
  else:
    field_to = get_field_value(field_to, field_from)

  return field_to


def json_merge_fields(recipe, parameters):
  """Recusrsively merges fields from an include.

     Field has format: { "field":{ "name":"???", "kind":"???", "default":???, "description":"???" }}

    Args:
      recipe: (dict) A dictionary representation fo the JSON script.
      parameters: (dict) A key value pair, where the value could be another field.

    Returns:
      fields: (list or dictionary) A list or dictionary representing each field recipe found in the JSON.

  """

  if isinstance(recipe, dict):
    for key, value in list(recipe.items()):
      if isinstance(value, dict) and 'field' in value:
        if value['field']['name'] in parameters:
          recipe[key] = json_merge_field(value, parameters[value['field']['name']])
      else:
        json_merge_fields(value, parameters)
  elif isinstance(recipe, list) or isinstance(recipe, tuple):
    for index, value in enumerate(recipe):
      if isinstance(value, dict) and 'field' in value:
        if value['field']['name'] in parameters:
          recipe[index] = json_merge_field(value, parameters[value['field']['name']])
      else:
        json_merge_fields(value, parameters)

  return recipe


def text_set_fields(text, variables):
  """Replaces fields in text with values from recipe.

     Fields in text are just are {field}, where field is a name of the variable.
     Missing fields default to blanks.

     Args:
       text (string) A paragraph possible containing {field} entries
       variables: (dict) The keys mapping to field, and values to replace

     Returns:
       A string with all values replaced. Or if an error occurs, original text.

  """

  text = RE_TEXT_FIELD.sub(r'{\1}', text)
  try:
    return text.format_map(defaultdict(str, variables))
  except ValueError:
    return text


def json_set_instructions(recipe, variables):
  """Replaces all fields in instructions with values provided.

     Checks if recipe['script']['instructions'] exist.  The replaces all %(???)s
     variables
     with values provided.  Note: %(???)s must match { "field":{ "name":"???" }}
     in JSON.

    Args:
      recipe: (dict) A dictionary representation of the JSON script.
      variables: (dict) A lookup table of all values to be replaced, key is name
        of field.

    Returns:
      Nothig. Instructions are modified in place.

  """

  if 'script' in recipe:
    if 'instructions' in recipe['script']:
      try:
        recipe['script']['instructions'] = [
            text_set_fields(instruction, variables)
            for instruction in recipe['script']['instructions']
        ]
      except KeyError:
        pass


def json_set_description(recipe, variables):
  """Replaces all fields in description with values provided.

     Checks if recipe['script']['description'] exist.  The replaces all %(???)s
     variables
     with values provided.  Note: %(???)s must match { "field":{ "name":"???" }}
     in JOSN.

    Args:
      recipe: (dict) A dictionary representation of the JSON script.
      variables: (dict) A lookup table of all values to be replaced, key is name
        of field.

    Returns:
      Nothig. Description is modified in place.

  """

  if 'script' in recipe:
    if 'description' in recipe['script']:
      try:
        recipe['script']['description'] = text_set_fields(
            recipe['script']['description'], variables)
      except KeyError:
        pass


def json_expand_queries(recipe, nodes=['query']):
  """Attempts to expand newlines in fields containing queries.

  Works only on fields, not lists.
  Uses first whitespace > 1 as indent indicator.
  Appends newlines to start of each indent indicator.

  Args:
    recipe - dictionary or list containing a recipe.
    nodes - the list of fields which contain queries.

  Returns:
    Dictionary modified in place with newlines for each query field.

  """

  if isinstance(recipe, dict):
    for key, value in recipe.items():
      if isinstance(value, str) and key in nodes:
        spaces = re.search('  +', value)
        if spaces:
          offset = spaces.end() - spaces.start()
          if offset > 1:
            recipe[key] = re.sub(r'\s{%d}' % offset, '\n' + (' ' * (offset - 2)), value)
      else:
        json_expand_queries(value, nodes)
  elif type(recipe) in (list, tuple):
    for value in recipe:
      json_expand_queries(value, nodes)

  return recipe


def recipe_markdown_html(text):
  return RE_MARKDOWN_LINK.sub(
    '<a href="\g<2>" target="_blank">\g<1></a>',
    RE_MARKDOWN_BOLD.sub('<strong>\g<1></strong>', text)
  )

def recipe_markdown_text(text):
  footnotes = {}
  def recipe_markdown_footnote(match):
    nonlocal footnotes
    footnotes[match.groups()] = len(footnotes) + 1
    return '{}-{}'.format(footnotes[match.groups()], match.group(1))

  return RE_MARKDOWN_LINK.sub(recipe_markdown_footnote, RE_MARKDOWN_BOLD.sub('\g<1>', text)), list(footnotes.keys())
